* Database Structure

A big part of om-next is that it creates norms about how to store you
application data.  Often we have pieces of data that appear in
multiple places in our UI.  Naturally, if it is the same data in
multiple places, we'd like to only have one real copy of it.  Any
other 'copies' are actually references.

To store data in om-next you follow this structure:

#+BEGIN_SRC clojure
(def app-state { :keyword { id real-information }})
#+END_SRC

or a real example:

#+BEGIN_SRC clojure
  (def app-state {:curr-user { "fenton.travers@gmail.com" {:age 21 :height 183}}})
#+END_SRC

We can now add a second location that 'refers' to the first like so:

#+BEGIN_SRC clojure
  (def app-state {:app-owner [:curr-user "fenton.travers@gmail.com"]
                  :curr-user { "fenton.travers@gmail.com" {:age 21 :height 183}}})
#+END_SRC

The format: ~[:keyword id]~ is called an ~ident~.  Its a reference to
some shared data.

* Datomic (Backend)

** Data Structure

Imagine we have datomic data that looks like:

#+BEGIN_SRC clojure
  {:db/id 1
   :car/make "Toyota"
   :car/model "Tacoma"
   :year 2013}

  {:db/id 2
   :car/make "BMW"
   :car/model "325xi"
   :year 2001}

  {:user/email "fenton.travers@gmail.com"
   :user/age 43
   :user/cars [{:db/id 1}
               {:db/id 2}]}
#+END_SRC

We can see the ~:user/cars~ field points to an array of cars.

In datomic we can use *pull* syntax to indicate which data we want.  A
valid pull /query/ would look like:

#+BEGIN_SRC clojure
  [:user/email
   :user/age
   {:user/cars
    [:db/id :car/make :car/model :year]}]
#+END_SRC

Datomic will happily /hydrate/ this /query/ to become:

#+BEGIN_SRC clojure
#:user{:email "fenton.travers@gmail.com",
       :age 43,
       :cars
       [{:db/id 17592186045419,
         :car/make "Toyota",
         :car/model "Tacomaaaa",
         :year 2013}
        {:db/id 17592186045420,
         :car/make "BMW",
         :car/model "325xi",
         :year 2001}]}
#+END_SRC
