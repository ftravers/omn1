* Overview

This tutorial will try to explain how to make the simplest
client/server app using om-next and datomic respectively.

Very big parts of this exercise are the shape of the data and querying
the data.  Lets look at how we might structure some data on the
backend (datomic) first.

* Datomic - the backend

** Data Structure

Imagine we have datomic data that looks like:

#+BEGIN_SRC clojure
  {:db/id 1
   :car/make "Toyota"
   :car/model "Tacoma"
   :year 2013}

  {:db/id 2
   :car/make "BMW"
   :car/model "325xi"
   :year 2001}

  {:db/id 3 
   :user/email "fenton.travers@gmail.com"
   :user/age 43
   :user/cars [{:db/id 1}
               {:db/id 2}]}
#+END_SRC

We can see the ~:user/cars~ field points to an array of cars that
fenton owns.

*NOTE:* I'm simplifying some aspects of this tutorial because I want
to keep focused on conceptual simplicity over absolute syntactical
correctness.

In datomic we can use *pull* syntax to indicate which data we want.  A
valid pull /query/ would look like:

#+BEGIN_SRC clojure
  [:user/email
   :user/age
   {:user/cars
    [:db/id :car/make :car/model :year]}]
#+END_SRC

which datomic will happily /hydrate/, or fill out the fields of this
/query/ to become:

#+BEGIN_SRC clojure
#:user{:email "fenton.travers@gmail.com",
       :age 43,
       :cars
       [{:db/id 1,
         :car/make "Toyota",
         :car/model "Tacoma",
         :year 2013}
        {:db/id 2,
         :car/make "BMW",
         :car/model "325xi",
         :year 2001}]}
#+END_SRC

So we have (kind of) demonstrated how we can extract data from
datomic, lets see if we can get this to jive with the om-next front
end now.

* Front End (om-next)

Now we need to structure the front end so we can easily get this info
from the backend.

So in om-next we'd normally construct this as two components.  One is
the parent component which would display the email and age of the
user, then we'd have a table that shows the cars they own.  The two
rows of the table are another component that is reused for each row.

Om-next components declare the data they require, in our example we'd
have something like:

#+BEGIN_SRC clojure
  (defui Car
    (query [this] [:db/id :car/make :car/model :year]))

  (defui MyCars
    (query [this] [:user/email :user/age {:user/cars (om/get-query Car)}]))
#+END_SRC

Now om-next will create one combined query which we can pass along to
datomic to /hydrate/.

So the final full query looks like:

#+BEGIN_SRC clojure
  [:user/email
   :user/age
   {:user/cars
    [:db/id :car/make :car/model :year]}]
#+END_SRC

Which is *identical* to the query we were able to pass to datomic, so
on the surface this looks great.  Next we'll look at how om-next
queries a backend and how it merges the results into the local data
structure.

* Om-Next Remotes

Om-next remotes are handled in a function definition.  This function
can be passed anything that the reader has.  A good place to look at
what it is sent is this URL: [[https://awkay.github.io/om-tutorial/#!/om_tutorial.E_State_Reads_and_Parsing][Alan Kay om-next tutorial - State Reads]].

The last parameter your remote handling function will recieve is a
callback function that you should call with the results of your actual
server side response.  Critical here is the shape of your local state
store, and the data that you are passing into the callback.

Lets look at the aspect of returning data from a remote function and
seeing how/what is able to be merged into your local state store.


#+BEGIN_SRC clojure

#+END_SRC

* Database Structure

A big part of om-next is that it creates norms about how to store your
application data.  Often we have pieces of data that appear in
multiple places in our UI.  Naturally, if it is the same data in
multiple places, we'd like to only have one real copy of it.  Any
other 'copies' are actually references.

To store data in om-next you follow this structure:

#+BEGIN_SRC clojure
(def app-state { :keyword { id real-information }})
#+END_SRC

or a real example:

#+BEGIN_SRC clojure
  (def app-state {:curr-user { "fenton.travers@gmail.com" {:age 21 :height 183}}})
#+END_SRC

We can now add a second location that 'refers' to the first like so:

#+BEGIN_SRC clojure
  (def app-state {:app-owner [:curr-user "fenton.travers@gmail.com"]
                  :curr-user { "fenton.travers@gmail.com" {:age 21 :height 183}}})
#+END_SRC

The format: ~[:keyword id]~ is called an ~ident~.  Its a reference to
some shared data.

