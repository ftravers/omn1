* Overview

This tutorial will try to explain how to make the simplest
client/server app using om-next and datomic respectively.

Very big parts of this exercise are the shape of the data and querying
the data.  Lets look at how we might structure some data on the
backend (datomic) first.

* Datomic (Backend)

** Data Structure

Imagine we have datomic data that looks like:

#+BEGIN_SRC clojure
  {:db/id 1
   :car/make "Toyota"
   :car/model "Tacoma"
   :year 2013}

  {:db/id 2
   :car/make "BMW"
   :car/model "325xi"
   :year 2001}

  {:db/id 3 
   :user/email "fenton.travers@gmail.com"
   :user/age 43
   :user/cars [{:db/id 1}
               {:db/id 2}]}
#+END_SRC

We can see the ~:user/cars~ field points to an array of cars.

In datomic we can use *pull* syntax to indicate which data we want.  A
valid pull /query/ would look like:

#+BEGIN_SRC clojure
  [:user/email
   :user/age
   {:user/cars
    [:db/id :car/make :car/model :year]}]
#+END_SRC

Datomic will happily /hydrate/ this /query/ to become:

#+BEGIN_SRC clojure
#:user{:email "fenton.travers@gmail.com",
       :age 43,
       :cars
       [{:db/id 17592186045419,
         :car/make "Toyota",
         :car/model "Tacomaaaa",
         :year 2013}
        {:db/id 17592186045420,
         :car/make "BMW",
         :car/model "325xi",
         :year 2001}]}
#+END_SRC

Okay, I cheate a little on the original ~:db/id~'s, in reality
inserting test data ~:db/id~'s looks more like: ~:db/id
#db/id[:db.part/user -1]~, but I want to keep this tutorial focused on
conceptual simplicity over absolute correctness.  I'll try to point
out where that occurs.
* Front End (om-next)

Now we need to structure the front end so we can easily get this info
from the backend.

So in om-next we'd normally construct this as two components.  One is
the parent component which would display the email and age of the
user, then we'd have a table that shows the cars they own.  The two
rows of the table are another component that is reused for each row.
* Database Structure

A big part of om-next is that it creates norms about how to store you
application data.  Often we have pieces of data that appear in
multiple places in our UI.  Naturally, if it is the same data in
multiple places, we'd like to only have one real copy of it.  Any
other 'copies' are actually references.

To store data in om-next you follow this structure:

#+BEGIN_SRC clojure
(def app-state { :keyword { id real-information }})
#+END_SRC

or a real example:

#+BEGIN_SRC clojure
  (def app-state {:curr-user { "fenton.travers@gmail.com" {:age 21 :height 183}}})
#+END_SRC

We can now add a second location that 'refers' to the first like so:

#+BEGIN_SRC clojure
  (def app-state {:app-owner [:curr-user "fenton.travers@gmail.com"]
                  :curr-user { "fenton.travers@gmail.com" {:age 21 :height 183}}})
#+END_SRC

The format: ~[:keyword id]~ is called an ~ident~.  Its a reference to
some shared data.

