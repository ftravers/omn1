To publish this tutorial as html do:

~C-c C-e h h~

* Tutorial 0: Initial Project

How to creat an absolute shell of a project:

#+BEGIN_SRC shell
╭─ ~/projects  ‹master*› 
╰─➤  lein new omn1
Generating a project called omn1 based on the 'default' template.
...
╭─ ~/projects  ‹master*› 
╰─➤  cd omn1
╭─ ~/projects/omn1  ‹master*› 
╰─➤  git init .
Initialized empty Git repository in /home/fenton/projects/omn1/.git/
╭─ ~/projects/omn1  ‹master*› 
╰─➤  git add .
╭─ ~/projects/omn1  ‹master*› 
╰─➤  git commit -a -m 'initial'
[master (root-commit) 2578d78] initial
 8 files changed, 285 insertions(+)
 ...
#+END_SRC

** Explanation

Now lets get a hello world app going.  There are some major
~project.clj~ file updates.  I wont go into them much.  The main file
to look at is: ~src/cljs/omn1/core.cljs~

The ~defui~ macro is how you create a component in om-next.
Components are how you manage the visual aspect of your project.  In
our simple component we are simply creating a ~div~ html element with
the text content being: "Hello World".

Finally we need to tie this component to the ~html~ page.  Here we use
the ~add-root!~ om function to do this.  The first argument is
a nil reconciler.  More on that later.  Then the root component, and
finally the id of the html tag where to mount this component.  See the
file ~resources/public/index.html~ to find the div with id "app".

** Testing

I cider-jack-in this project and then run figwheel in the project to
get a cljs repl in emacs.  Then I can just go to the URL:
http://localhost:3449/ to have a look at the results.

* Tutorial 1a: Adding state and reading from it

Okay, we've really modified the ~core.cljs~ file here.  Lets break it
down.  First we created a ~readr~ function (method).  It has access to
the app state via the ~env~ variable: ~@(:state env)~.

Stick ~(.log js/console "STATE: " (str @(:state env)))~ into the readr
function just before you return the ~val~, to confirm this prints the
state.

~keyz~, is passed whatever is in your ~query~ from the component
definition.  You can log that out if you like too.

The result of the reading is stuck into the ~props~ that is passed to
the component.  Even though the reader returns {:value ...}, behind
the scenes, om converts the key to be :title instead.  I.e. that which
was passed to via the query to the reader becomes the key for the
props.

Thats why we access the title via: (:title ...) versus (:value ...).

Finally the rest is just wiring the different parts together.  We set
the reader in the parser.  The reconciler connects the parser to the
app state.  Finally this more full fledged reconciler is connected to
the component via the ~add-root!~ function.

* Tutorial 1b: Demo query reader decoupling

In this version of the code we demonstrate the decoupling of the keys
of the query from what the reader returns.  Our reader now effectively
ignores the key we pass it, and we reference ~:blah~ only in our
component.  Okay this is a bit of a useless reader as it only ever
returns the title.

* Tutorial 2: Move pieces around

Om will also run on the server side...to a point.  The parts we have
so far of an om-next app are: the component, reading (and writing)
functions, the parser, the reconciler, and the ~add-root!~ function

Their jobs are as follows: the ~add-root!~ function connects the root
component with the reconciler.  The parser manages reading (and
writing as we'll see in a future tutorial) from the state.  The
reconciler connects the parser to the state.

We can move the parser, reading function and reconciler into a
~*.cljc~ file and test it in a simple clojure repl (not a
clojurescript repl).  This allows us to use the cider debugger to step
through the code and inspect variables, nice!

We are going to start with a file/dir layout like:

#+BEGIN_SRC shell
╭─ ~/projects/omn1
╰─➤  tree src
src
`-- cljs
    `-- omn1
        `-- core.cljs
#+END_SRC

and move to:

#+BEGIN_SRC shell
╭─fenton@ss9 ~/projects/omn1  ‹master*› 
╰─➤  tree src
src
|-- cljc
|   `-- omn1
|       `-- recon.cljc
`-- cljs
    `-- omn1
        `-- core.cljs
#+END_SRC

Now startup a repl (not a figwheel one) and do:

#+BEGIN_SRC clojure
omn1.recon> (parser {:state my-state} [:title])
{:title "Hello World 2!"}
omn1.recon> 
#+END_SRC

So you see we passed in some query, and we can see what the results of
parsing that query with our state is.  Now we can work on a big chunk
of our Web App without having to use a browser/figwheel, thats cool!
