#+TITLE: Om Next Tutorial
* About These Tutorials

These tutorials are aimed at a beginner audience.  They try to be
brief yet complete.  Less can be more.  However I try not to leave any
detail out either.  Gaps in explanation can lead to confusion.

In summary I hope for these tutorials to be short, complete and
approachable for beginners.  I appreciate constructive feedback, so
let me know if, in your opinion, I fail or succeed to achieve these
goals.

* Overview

This tutorial will try to explain how to make the simplest
client/server app using om-next and datomic respectively.

If you are not familiar with Datomic, I suggest you checkout [[https://www.reddit.com/r/Clojure/comments/5zu1oc/my_datomic_tutorial_feedback_sought/][my
 tutorial]] on it.

Very big parts of this task have to do with the shape of the data and
querying the data.  Lets look at how we might structure some data on
the backend (datomic) first.

* Daily Setup
** Start the backend

Start the backend outside of emacs at the command prompt:

#+BEGIN_SRC 
cd ~/projects/omn1be; lein repl

(load "websocket") (in-ns 'omn1be.websocket) (start) (in-ns 'omn1be.router)
#+END_SRC

** Start frontend

Open project ~omn1~ and file ~src/omn1/webpage.cljs~.  

Start a REPL there.  Then run figwheel.

Open your browser at: http://localhost:3449/

** Testing from front end

#+BEGIN_SRC clojure
omn1.webpage>   @app-state
{:authenticated false}

;; a mutation
omn1.webpage> (om/transact! reconciler `[(user/login {:user/name "fenton" :user/password "passwErd"})])
omn1.webpage> @app-state
{:authenticated false, :user/name "fenton", :user/password "welcome1"}

;; a parameterized query
omn1.webpage> (om/transact! reconciler '[(:user/authenticated {:user/name "fenton" :user/password "passwErd"})])

#+END_SRC

** Testing from backend

#+BEGIN_SRC clojure
omn1be.router=> (parser {:database (core/db)} '[(user/login {:user/name "fenton", :user/password "passwErd"})])
#:user{login {:keys (:user/name :user/password), :valid-user true}}
omn1be.router=> (api {:function :user/login :params {:user/name "fenton", :user/password "passwErd"}})
{:valid-user true}
#+END_SRC

* SEND USERNAME PASSWORD

So we can send something to the backend using:

#+BEGIN_SRC clojure
  (om/transact!
   reconciler
   `[(user/login
      {:user/name "fenton"
       :user/password "passwErd"})])
#+END_SRC

* Datomic - the backend
** Data Structure

Imagine we have datomic data that looks like:

#+BEGIN_SRC clojure
  {:db/id 1
   :car/make "Toyota"
   :car/model "Tacoma"
   :year 2013}

  {:db/id 2
   :car/make "BMW"
   :car/model "325xi"
   :year 2001}

  {:db/id 3 
   :user/user "ftravers"
   :user/age 54
   :user/cars [{:db/id 1}
               {:db/id 2}]}
#+END_SRC

We can see the ~:user/cars~ field points to an array of cars that
fenton owns.

*NOTE:* I'm simplifying some aspects of this tutorial because I want
to keep focused on conceptual simplicity over absolute syntactical
correctness.

In datomic we can use *pull* syntax to indicate which data we want.  A
valid pull /query/ would look like:

#+BEGIN_SRC clojure
  [:user/name
   :user/age
   {:user/cars
    [:db/id :car/make :car/model :year]}]
#+END_SRC

which datomic will happily /hydrate/, or fill out the fields of this
/query/ to become:

#+BEGIN_SRC clojure
#:user{:email "ftravers",
       :age 43,
       :cars
       [{:db/id 1,
         :car/make "Toyota",
         :car/model "Tacoma",
         :year 2013}
        {:db/id 2,
         :car/make "BMW",
         :car/model "325xi",
         :year 2001}]}
#+END_SRC

So we have (kind of) demonstrated how we can extract data from
datomic, lets see if we can get this to jive with the om-next front
end now.

* Front End (om-next)

Now we need to structure the front end so we can easily get this info
from the backend.

So in om-next we'd normally construct this as two components.  One is
the parent component which would display the email and age of the
user, then we'd have a table that shows the cars they own.  The two
rows of the table are another component that is reused for each row.

Om-next components declare the data they require, in our example we'd
have something like:

#+BEGIN_SRC clojure
  (defui Car
    (query [this] [:db/id :car/make :car/model :year]))

  (defui MyCars
    (query [this] [:user/name :user/age {:user/cars (om/get-query Car)}]))
#+END_SRC

Now om-next will create one combined query which we can pass along to
datomic to /hydrate/.

So the final full query looks like:

#+BEGIN_SRC clojure
  [:user/name
   :user/age
   {:user/cars
    [:db/id :car/make :car/model :year]}]
#+END_SRC

Which is *identical* to the query we were able to pass to datomic, so
on the surface this looks great.  Next we'll look at how om-next
queries a backend and how it merges the results into the local data
structure.

* Om-Next Remotes

Om-next remotes are handled in a function definition.  This function
can be passed anything that the reader has.  A good place to look at
what it is sent is this URL: [[https://awkay.github.io/om-tutorial/#!/om_tutorial.E_State_Reads_and_Parsing][Alan Kay om-next tutorial - State Reads]].
Its a long page without anchors so go to section: "Implementing Read",
then scroll down to the numbered list where he describes the three
parameters passed into ~read~.

The last parameter your remote handling function will recieve is a
callback function that you should be called with the results of your
actual server side response.  Critical here is the shape of your local
state store, and the data that you are passing into the callback.

Lets look at the aspect of returning data from a remote function and
seeing how/what is able to be merged into your local state store.

#+BEGIN_SRC clojure

#+END_SRC

* Database Structure

A big part of om-next is that it creates norms about how to store your
application data.  Often we have pieces of data that appear in
multiple places in our UI.  Naturally, if it is the same data in
multiple places, we'd like to only have one real copy of it.  Any
other 'copies' are actually references.

To store data in om-next you follow this structure:

#+BEGIN_SRC clojure
(def app-state { :keyword { id real-information }})
#+END_SRC

or a real example:

#+BEGIN_SRC clojure
  (def app-state {:curr-user { "ftravers" {:age 21 :height 183}}})
#+END_SRC

We can now add a second location that 'refers' to the first like so:

#+BEGIN_SRC clojure
  (def app-state {:app-owner [:curr-user "ftravers"]
                  :curr-user { "ftravers" {:age 21 :height 183}}})
#+END_SRC

The format: ~[:keyword id]~ is called an ~ident~.  Its a reference to
some shared data.

